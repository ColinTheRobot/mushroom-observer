#!/bin/bash

id=$1
ext=$2
set_size=$3

source $(dirname "$0")/bash_include.sh
keep_cumulative_log

images_root=$app_root/public/images

orig_layers=$images_root/orig/$id-"*".jpg
orig_file=$images_root/orig/$id.$ext
full_file=$images_root/orig/$id.jpg
huge_file=$images_root/1280/$id.jpg
large_file=$images_root/960/$id.jpg
medium_file=$images_root/640/$id.jpg
small_file=$images_root/320/$id.jpg
thumb_file=$images_root/thumb/$id.jpg

if [[ $1 == "-h" || $1 == "--help" ]]; then cat <<EOH; exit -1; fi

USAGE:
    script/process_image <id> <extension> <set_size_in_database?>

DESCRIPTION:
    This is used by the webserver to resize and transfer uploaded images to
    the image server(s).  It is intended to run asynchronously.  One of these
    jobs is spwaned for each image uploaded.  It takes these steps:

    1. converts original to jpeg if necessary
    2. reorients it correctly if necessary
    3. sets size of original image in database if 'set' flag used
    4. creates the five smaller-sized copies
    5. copies all files to the image server(s) if in production mode
    6. emails webmaster if there are any errors

    It ensures that no other processes are running ImageMagick or scp before
    it runs its own commands.  If another is running, it sleep a few seconds
    and tries again.

EOH

# Convert the original image to a JPEG.
if [[ $orig_file != $full_file ]]; then
  wait_for "(convert|jpegresize)"
  run convert -quality 90 $orig_file $full_file

  # If there are multiple layers, ImageMagick saves them as 1234-N.jpg.
  # Take the first one, and delete the rest.
  if [[ ! -e $full_file ]]; then
    biggest_layer=`ls -rS $orig_layers | tail -1`
    if [[ -e $biggest_layer ]]; then
      run mv $biggest_layer $full_file
      run rm $orig_layers
    fi
  fi
fi

# Make sure image is oriented correctly.
run exifautotran $full_file

if (( $set_size )); then
  size=$( script/jpegsize $full_file | sed "s/.*: //" )
  w=$( echo $size | sed "s/ .*//" )
  h=$( echo $size | sed "s/.* //" )
  run_mysql "UPDATE images SET width=$w, height=$h WHERE id=$id"
fi

# Image processing theory says that reducing images by 50% at a time is optimal.
wait_for "(convert|jpegresize)"
run jpegresize 1280x1280 -q 70 --max-size $full_file $huge_file
run jpegresize 960x960   -q 70 --max-size $huge_file $large_file
run jpegresize 640x640   -q 70 --max-size $huge_file $medium_file
run jpegresize 320x320   -q 80 --max-size $medium_file $small_file
run jpegresize 160x160   -q 90 --max-size $small_file $thumb_file

# ImageMagick slurps the entire image into memory all at once.
# Our jpegresize is much more memory-efficient but otherwise equivalent.
# run convert -thumbnail "1280x1280>" -quality 70 $full_file $huge_file
# run convert -thumbnail "960x960>"   -quality 70 $huge_file $large_file
# run convert -thumbnail "640x640>"   -quality 70 $huge_file $medium_file
# run convert -thumbnail "320x320>"   -quality 80 $medium_file $small_file
# run convert -thumbnail "160x160>"   -quality 90 $small_file $thumb_file

if (( $production )); then
  for server in ${image_servers[@]}; do
    wait_for scp
    run scp $thumb_file  $server/thumb/$id.jpg
    run scp $small_file  $server/320/$id.jpg
    run scp $medium_file $server/640/$id.jpg
    run scp $large_file  $server/960/$id.jpg
    run scp $huge_file   $server/1280/$id.jpg
    run scp $full_file   $server/orig/$id.jpg
    if [[ $orig_file != $full_file ]]; then
      run scp $orig_file $server/orig/$id.$ext
    fi
  done
fi

if (( $production && !$errors )); then
  run_mysql "UPDATE images SET transferred=TRUE WHERE id=$id"
fi

if (( $production && $errors )); then
  mutt -s "[MO] process_image" $webmaster_email < $log_file
fi

exit $errors
