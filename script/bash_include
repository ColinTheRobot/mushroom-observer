#
#  Standard bash global constants and functions.
#
#  app_root             Application root path.
#  webmaster_email      Email address of webmaster.
#  production           Flag: 1 if in production mode.
#  development          Flag: 1 if in development mode.
#  testing              Flag: 1 if in test mode.
#  errors               Flag: 1 if any errors occurred in log_cmd or log_mysql.
#  log_file             Temporary log file.
#                      
#  keep_cumulative_log  Run this if you want a permanent cumulative log kept for this command.
#  rails_constant       Extract a global constant from ruby config/consts.rb.
#  image_servers        Array of image servers.
#  time_stamp           Prints time stamp to stdout: "YYYYMMDD HH:MM:SS TZ"
#  wait_for             Wait for any other processes to finish running a given command then return.
#  log_cmd              Log and run a command, and record error if one occurs.
#  run_mysql            Run a mysql command and send output to stdout (in tab-delimited format without header).
#  log_mysql            Log and run a mysql command, and record error if one occurs.
#  send_mail            Send an email via mutt (or send to stdout in test mode).
#  die                  Print error message to stderr then exit with non-zero status.
#  warn                 Print error message to stderr then return.
#
################################################################################

path=(/usr/local/bin /usr/bin /bin)
webmaster_email=webmaster@mushroomobserver.org

[[ $RAILS_ENV == "production" ]] && production=1 || production=0
[[ $RAILS_ENV == "test" ]] && testing=1 || testing=0
(( !$production && !testing )) && development=1 || development=0

# This flag gets set to 1 if any 'run' or 'run_mysql' commands fail.
errors=0

# Application root = $RAIlS_ROOT.
app_root="$( cd "$(dirname "$0")"; pwd -P | sed 's/\/script.*//' )"

# Temporary log file, e.g., $RAILS_ROOT/log/process_image.1234
log_file=$app_root/log/$( basename $0 ).$$

# Tell it to keep a running log of all the times this script is run.
function keep_cumulative_log {
  cumulative_log_file=$app_root/log/$( basename $0 ).log
}

# Clean up logs before exit.
function clean_log {
  if [[ $cumulative_log_file != "" && -e $log_file ]]; then
    cat $log_file >> $cumulative_log_file
  fi
  rm -f $log_file
}
trap clean_log EXIT

# Grab constant from rails configuration (consts.rb and consts-site.rb).
#   path=$( rails_constant LOCAL_IMAGE_FILES )
function rails_constant {
  ruby -I$app_root/config -e "require 'import_constants.rb'" -e "print $1"
}

# Get mysql login information.
config=$app_root/config/database.yml
db_database=$( grep -A 20 $RAILS_ENV: $config | grep database: | head -1 | sed "s/.*: *//" )
db_username=$( grep -A 20 $RAILS_ENV: $config | grep username: | head -1 | sed "s/.*: *//" )
db_password=$( grep -A 20 $RAILS_ENV: $config | grep password: | head -1 | sed "s/.*: *//" )

# Get a list of image servers.
for config in \
  $app_root/config/consts-site.rb \
  $app_root/config/consts.rb
do
  if [[ -f $config && $(grep -c IMAGE_SOURCES $config) -gt 0 ]]; then
    img_config=$config
    break
  fi
done
declare -a image_servers=( $(sed -n '/IMAGE_SOURCES/,/^}/p' $img_config | egrep -v '^ *#' | grep :write | sed -e 's/.*"\(.*\)".*/\1/') )

if (( $testing )); then
  # Override real image server(s) with two fake local ones.
  declare -a image_servers=( $app_root/tmp/image_server1 $app_root/tmp/image_server2 )
  for server in ${image_servers[@]}; do
    mkdir -p $server/{orig,1280,960,640,320,thumb}
  done
fi

function time_stamp {
  date "+%Y%m%d %H:%M:%S %Z"
}

# Wait until no other processes are running the given command(s). Examples:
#   wait_for scp
#   wait_for "(convert|jpegresize)"
function wait_for {
  while (ps -e | grep " $*\$" > /dev/null); do sleep 5; done
}

# Run the given command, logging date and any stdout or stderr. Example:
#   run convert -thumbnail 200x200 large.jpg thumb.jpg
function log_cmd {
  echo $(time_stamp)">" $* >> $log_file
  if !($* >> $log_file 2>&1); then
    errors=1
    echo "**** FAILED ****" >> $log_file
    return 1
  else
    return 0
  fi
}

# Run the given mysql command without logging or anything else.
function run_mysql {
  mysql -s -q -u "$db_username" -p"$db_password" "$db_database" -e "$*"
}

# Run the given mysql command, logging the command and any errors. Example:
#   run_mysql "UPDATE images SET transferred=true WHERE id=$id"
function log_mysql {
  echo "$(time_stamp)>" mysql "\"$*\"" >> $log_file
  if !( run_mysql "$*" >> $log_file 2>&1 ); then
    errors=1
    echo "**** FAILED ****" >> $log_file
    return 1
  else
    return 0
  fi
}

# Send an email:
#   send_mail "subject line" address1 address2 < message.txt
function send_mail {
  if [[ $1 = "-s" ]]; then
    subject="$2"
    shift
    shift
  fi
  if (( $testing )); then
    $app_root/script/mutt_test -s "$subject" $@
  else
    mutt -s "$subject" $@
  fi
}

# Equivalent of perl carp command.
function warn {
  echo $* 1>&2
}

# Equivalent of perl die command.
function die {
  echo $* 1>&2
  exit 1
}
