#
#  Standard bash global constants and functions.
#
#  app_root             Application root path.
#  webmaster_email      Email address of webmaster.
#  production           Flag: 1 if in production mode.
#  development          Flag: 1 if in development mode.
#  testing              Flag: 1 if in test mode.
#  errors               Flag: 1 if any errors occurred in log_cmd or log_mysql.
#  log_file             Temporary log file.
#                      
#  keep_cumulative_log  Run this if you want a permanent cumulative log kept for this command.
#  rails_constant       Extract a global constant from ruby config/consts.rb.
#  image_servers        Array of image servers.
#  time_stamp           Prints time stamp to stdout: "YYYYMMDD HH:MM:SS TZ"
#  wait_for             Wait for any other processes to finish running a given command then return.
#  log_cmd              Log and run a command, and record error if one occurs.
#  run_mysql            Run a mysql command and send output to stdout (in tab-delimited format without header).
#  log_mysql            Log and run a mysql command, and record error if one occurs.
#  send_mail            Send an email via mutt (or send to stdout in test mode).
#  die                  Print error message to stderr then exit with non-zero status.
#  warn                 Print error message to stderr then return.
#
################################################################################

path=(/usr/local/bin /usr/bin /bin)
webmaster_email=webmaster@mushroomobserver.org

[[ $RAILS_ENV == "production" ]] && production=1 || production=0
[[ $RAILS_ENV == "test" ]] && testing=1 || testing=0
(( !$production && !testing )) && development=1 || development=0

# This flag gets set to 1 if any 'run' or 'run_mysql' commands fail.
errors=0

# Application root = $RAIlS_ROOT.
app_root="$( cd "$(dirname "$0")"; pwd -P | sed 's/\/script.*//' )"

# Temporary log file, e.g., $RAILS_ROOT/log/process_image.1234
log_file=$app_root/log/$( basename $0 ).$$

# Tell it to keep a running log of all the times this script is run.
function keep_cumulative_log {
  cumulative_log_file=$app_root/log/$( basename $0 ).log
}

# Clean up logs before exit.
function clean_log {
  if [[ $cumulative_log_file != "" && -e $log_file ]]; then
    cat $log_file >> $cumulative_log_file
  fi
  rm -f $log_file
}
trap clean_log EXIT

# Grab constant from rails configuration (consts.rb and consts-site.rb).
#   path=$( rails_constant MO.local_image_files )
function rails_constant {
  $app_root/script/config $*
}

# Get mysql login information.
file=$app_root/config/database.yml
db_database=$( grep -A 20 $RAILS_ENV: $file | grep database: | head -1 | sed "s/.*: *//" )
db_username=$( grep -A 20 $RAILS_ENV: $file | grep username: | head -1 | sed "s/.*: *//" )
db_password=$( grep -A 20 $RAILS_ENV: $file | grep password: | head -1 | sed "s/.*: *//" )

# Get array of image servers. Usage:
#   get_image_servers
#   for server in ${image_servers[@]}; do
#     echo $server url: ${image_server_data[$server,url]}
#   done
# Format from "config image_servers" is:
#   name;type://path;thumb,small
declare image_root
declare -a image_servers
declare -a image_server_data
declare -a image_sizes
declare -a image_subdirs
declare -a size_to_subdir
declare -a subdir_to_size

function get_image_servers {
  image_root=$( rails_constant MO.local_image_files )
  image_sizes=( thumbnail small medium large huge full_size )
  image_subdirs=( 1280 320 640 960 orig thumb )

  size_to_subdir[thumbnail]=thumb
  size_to_subdir[small]=320
  size_to_subdir[medium]=640
  size_to_subdir[large]=960
  size_to_subdir[huge]=1280
  size_to_subdir[full_size]=orig

  subdir_to_size[thumb]=thumbnail
  subdir_to_size[320]=small
  subdir_to_size[640]=medium
  subdir_to_size[960]=large
  subdir_to_size[1280]=huge
  subdir_to_size[orig]=full_size

  image_server_data[local,url]="file://$image_root"
  image_server_data[local,type]="file"
  image_server_data[local,path]="$image_root"
  image_server_data[local,subdirs]="thumb,320,640,960,1280,orig"

  for line in $($app_root/script/config image_servers); do
    name=$(    echo "$line" | sed 's/;.*//' )
    url=$(     echo "$line" | sed -e 's/^[^;]*;//' -e 's/;.*//' )
    type=$(    echo "$line" | sed -e 's/^[^;]*;//' -e 's/:.*//' )
    path=$(    echo "$line" | sed -e 's/^.*:\/\///' -e 's/;.*//' )
    subdirs=$( echo "$line" | sed 's/.*;//' )
    image_servers=( "${image_servers[@]}" "$name" )
    image_server_data[$name,url]="$url"
    image_server_data[$name,type]="$type"
    image_server_data[$name,path]="$path"
    image_server_data[$name,subdirs]="$subdirs"
  done
}

function image_server_has_subdir {
  echo ${image_server_data[$1,subdirs]} | grep -q "$2"
}

function time_stamp {
  date "+%Y%m%d %H:%M:%S %Z"
}

# Wait until no other processes are running the given command(s). Examples:
#   wait_for "(scp|ssh)"
#   wait_for "(convert|jpegresize)"
function wait_for {
  while (ps -e | grep " $*\$" > /dev/null); do sleep 5; done
}

# Run the given command, logging date and any stdout or stderr. Example:
#   run convert -thumbnail 200x200 large.jpg thumb.jpg
function log_cmd {
  echo $(time_stamp)">" $* >> $log_file
  if !($* >> $log_file 2>&1); then
    errors=1
    echo "**** FAILED ****" >> $log_file
    return 1
  else
    return 0
  fi
}

# Run the given mysql command without logging or anything else.
function run_mysql {
  mysql -s -q -u "$db_username" -p"$db_password" "$db_database" -e "$*"
}

# Run the given mysql command, logging the command and any errors. Example:
#   run_mysql "UPDATE images SET transferred=true WHERE id=$id"
function log_mysql {
  echo "$(time_stamp)>" mysql "\"$*\"" >> $log_file
  if !( run_mysql "$*" >> $log_file 2>&1 ); then
    errors=1
    echo "**** FAILED ****" >> $log_file
    return 1
  else
    return 0
  fi
}

# Send an email:
#   send_mail "subject line" address1 address2 < message.txt
function send_mail {
  if [[ $1 = "-s" ]]; then
    subject="$2"
    shift
    shift
  fi
  if (( $testing )); then
    $app_root/script/mutt_test -s "$subject" $@
  else
    mutt -s "$subject" $@
  fi
}

# Copy one image file from a given server.
#   copy_file_from_server "cdmr" "thumb/1234.jpg"
function copy_file_from_server {
  server=$1
  file=$2
  case ${image_server_data[$server,type]} in
  "file")
    path=${image_server_data[$server,path]}
    cp $path/$file $image_root/$file || die "Failed to get $file from $path."
    ;;
  "ssh")
    wait_for "(scp|ssh)"
    path=${image_server_data[$server,path]}
    scp $path/$file $image_root/$file || die "Failed to get $file from $path."
    ;;
  "http")
    url=${image_server_data[$server,url]}
    wget "$url/$file" -O $image_root/$file || die "Failed to get $file from $url."
    ;;
  *)
    url=${image_server_data[$server,url]}
    die "Don't know how to get $file from $url."
  esac
}

# Copy one image file to a given server.
#   copy_file_from_server "cdmr" "thumb/1234.jpg"
function copy_file_to_server {
  server=$1
  file=$2
  case ${image_server_data[$server,type]} in
  "file")
    path=${image_server_data[$server,path]}
    cp $image_root/$file $path/$file || die "Failed to transfer $file to $path."
    ;;
  "ssh")
    wait_for "(scp|ssh)"
    path=${image_server_data[$server,path]}
    scp $image_root/$file $path/$file || die "Failed to transfer $file to $path."
    ;;
  *)
    url=${image_server_data[$server,url]}
    die "Don't know how to transfer $file to $url."
  esac
}

# Equivalent of perl carp command.
function warn {
  echo $* 1>&2
}

# Equivalent of perl die command.
function die {
  echo $* 1>&2
  exit 1
}
