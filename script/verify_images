#!/usr/bin/env ruby
#
#  Get listings of all local and remote image files, transfer ones that need
#  to be transferred, and delete ones that are no longer needed locally.
#
################################################################################

require File.expand_path('../../config/import_constants',  __FILE__)

def cache_file(server)
  if DEVELOPMENT || PRODUCTION
    "#{LOCAL_PATH}/#{server}.files"
  else
    "#{LOCAL_PATH}/#{server}.files.test"
  end
end

def refresh_local_cache(path)
  cmd = "ls -s #{path}"
  read_subdirs(:local, cmd)
end

def refresh_remote_cache(server, url)
  if url.match(/^file:\/\/(.*)/)
    path = Regex.last_match[1]
    cmd = "ls -s #{path}"
    read_subdirs(server, cmd)
  elsif url.match(/^ssh:\/\/(.*?)\/(.*)/)
    host = Regex.last_match[1]
    path = Regex.last_match[2]
    cmd = "ssh #{host} ls -s #{path}"
    read_subdirs(server, cmd)
  else
    $stderr.puts "Don't know how to access #{url}."
  end
end

def read_subdirs(server, cmd)
  file = cache_file(server)
  Kernel.open("| sort > #{file}", "w") do |output|
    SIZES.values.sort.each do |_, subdir|
      puts "Getting #{server} #{subdir}..." if VERBOSE
      num = read_dir(subdir, cmd, output)
      puts "  #{num} files" if VERBOSE
    end
  end
end

def read_dir(subdir, cmd, output)
  num = 0
  Kernel.open("| #{cmd}/#{subdir}").each do |line|
    size, file = line.chomp.split
    output.puts("#{subdir}/#{file} #{size}") if size != 'total'
    num += 1
  end
  return num
end

def files_to_upload(server)
  puts "Getting files to upload to #{server}..." if VERBOSE
  local  = File.open(cache_file(:local))
  remote = File.open(cache_file(server))
  result = []
  remote_file = ""
  until local.eof?
    local_file, local_size = local.read_line.chomp.split
    loop do
      if remote_file >= local_file
        result << local_file if remote_file != local_file || remote_size != local_size
        break
      elsif remote.eof?
        result << local_file
        break
      else
        remote_file, remote_size = remote.read_line.chomp.split 
      end
    end
  end
  return result
end

def files_to_delete(servers)
  puts "Getting files to delete..." if VERBOSE
  result = nil
  servers.each do |server|
    files = files_in_common(server)
    result = result ? result & files : files
  end
  return result
end

def files_in_common(server)
  local  = File.open(cache_file(:local))
  remote = File.open(cache_file(server))
  result = []
  remote_file = ""
  keep = KEEP_THESE_IMAGE_SIZES.map {|x| SIZES[x]}
  until local.eof? || remote.eof?
    local_file, local_size = local.read_line.chomp.split
    subdir = local_file.split('/').first
    next if keep[subdir] 
    loop do
      if remote_file >= local_file
        result << local_file if remote_file == local_file && remote_size == local_size
        break
      elsif remote.eof?
        break
      else
        remote_file, remote_size = remote.read_line.chomp.split 
      end
    end
  end
  return result
end

def upload_files(server, files)
  url = IMAGE_SOURCES[server][:write]
  if url.match(/^file:\/\/(.*)/)
    path = Regex.last_match[1]
    upload_via_file(server, files, path)
  elsif url.match(/^ssh:\/\/(.*?)\/(.*)/)
    host = Regex.last_match[1]
    path = Regex.last_match[2]
    upload_via_ssh(server, files, host, path)
  else
    $stderr.puts "Don't know how to access #{url}."
  end
end

def upload_via_file(server, files, path)
  puts "\nUploading to #{server}:" if VERBOSE
  files.each do |file|
    src  = "#{LOCAL_PATH}/#{file}"
    dest = "#{path}/#{file}"
    puts file if VERBOSE
    FileUtils.cp(src, dest) unless TEST_MODE
  end
end

def upload_via_ssh(server, files, host, path)
  puts "\nUploading to #{server}:" if VERBOSE
  tempfile = Tempfile.new("verify_images").path
  File.open(tempfile, "w") do |output|
    files.each { |file| output.puts(file) }
  end
  flags = VERBOSE ? "-xvPf" : "-xPf"
  cmd = <<-END.unindent
    ( cd #{LOCAL_PATH} &&
      tar -T #{tempfile} -cf - |
      ssh #{host} \\(cd #{path}\\; tar #{flags} -\\) )
  END
  if !TEST_MODE
    system(cmd)
  elsif VERBOSE
    puts cmd
  end
end

def delete_files(files)
  puts "\nDeleting:" if VERBOSE
  files.each do |file|
    puts file if VERBOSE
    FileUtils.rm("#{LOCAL_PATH}/#{file}") unless TEST_MODE
  end
end

################################################################################

SIZES = {
  thumbnail: 'thumb',
  small:     '320',
  medium:    '640',
  large:     '960',
  huge:      '1280',
  full_size: 'orig'
}

if DEVELOPMENT || PRODUCTION
  LOCAL_PATH = LOCAL_IMAGE_FILES
  SERVERS = IMAGE_SOURCES.keys.reject do |server|
    IMAGE_SOURCES[server][:write].blank?
  end
else
  LOCAL_PATH = "#{APP_ROOT}/tmp/local_images"
  SERVER_URLS = {
    :remote1 => { :write => "file://#{APP_ROOT}/tmp/image_server1" },
    :remote2 => { :write => "file://#{APP_ROOT}/tmp/image_server2",
                  :sizes => [ :thumbnail, :small ] }
  }
end

USE_CACHE = ARGV.include?('-c') || ARGV.include?('--use-cache')
TEST_MODE = ARGV.include?('-t') || ARGV.include?('--test')
VERBOSE   = ARGV.include?('-v') || ARGV.include?('--verbose')

valid_flags = ['-c', '-t', '-v', '--use-cache', '--test', '--verbose']
$stderr.print(<<END) && exit(1) if (ARGV - valid_flags).any?

USAGE
  script/verify_images.prl [--use-cache|verbose|test]

OPTIONS
 -c | --use_cache
 -t | --test
 -v | --verbose

DESCRIPTION
  Gets listings of the size of all image files stored locally and on the image
  servers.  Uploads any that are different than the local copy.  Deletes local
  copies of any image files which have been transferred successfully.

END

unless USE_CACHE
  refresh_local_cache(LOCAL_PATH)
  for server in SERVERS
    url = IMAGE_SOURCES[server][:write]
    refresh_remote_cache(server, url)
  end
end

for server in SERVERS
  files = files_to_upload(server)
  upload_files(server, files)
end
files = files_to_delete(SERVERS)
delete_files(files)

exit 0
